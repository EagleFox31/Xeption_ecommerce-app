import { Category } from './category.entity';
import { Brand } from './brand.entity';

export enum ProductTierEnum {
  ENTRY = "entry",
  STANDARD = "standard", 
  PREMIUM = "premium",
  PRO = "pro"
}

export interface ProductSpecification {
  id: string;
  label: string;
  value: string;
  unit?: string;
  valueType: string;
  position: number;
}

export interface ProductFeature {
  id: string;
  title: string;
  iconUrl?: string;
  highlight: boolean;
  position: number;
}

export interface ProductImage {
  id: string;
  imageUrl: string;
  position: number;
}

export interface ProductVariant {
  id: string;
  variantKey: string;
  attrs: Record<string, any>;
  extraPriceXaf: number;
  stockQty: number;
}

export interface ProductSeries {
  id: string;
  name: string;
  slug: string;
}

export class Product {
  constructor(
    public readonly id: string,
    public readonly name: string,
    public readonly slug: string,
    public readonly sku: string, // Auto-generated by SQL triggers assign_sku_from_category & get_next_sku
    public readonly categoryId: string,
    public readonly category?: Category,
    public readonly brandId?: string,
    public readonly brand?: Brand,
    public readonly seriesId?: string,
    public readonly series?: ProductSeries,
    public readonly priceXaf: number = 0,
    public readonly currency: string = "XAF",
    public readonly promoPct: number = 0,
    public readonly promoPriceXaf?: number,
    public readonly stockQty: number = 0,
    public readonly weightKg?: number,
    public readonly dimensionsMm?: Record<string, number>,
    public readonly specs?: Record<string, any>, // Cached by refresh_product_specs_cache trigger
    public readonly description?: string,
    public readonly i18nDescriptions?: Record<string, any>, // Synced by sync_i18n_descriptions trigger
    public readonly tier: ProductTierEnum = ProductTierEnum.STANDARD,
    public readonly hasVariants: boolean = false, // Auto-updated by update_product_has_variants trigger
    public readonly specifications: ProductSpecification[] = [],
    public readonly features: ProductFeature[] = [],
    public readonly images: ProductImage[] = [],
    public readonly variants: ProductVariant[] = [],
    public readonly createdAt: Date = new Date(),
    public readonly updatedAt: Date = new Date(), // Auto-updated by set_updated_at trigger
  ) {}

  public isInStock(): boolean {
    return this.stockQty > 0;
  }

  public hasPromotion(): boolean {
    return this.promoPct > 0 && this.promoPriceXaf !== undefined;
  }

  public getFinalPrice(): number {
    if (this.hasPromotion() && this.promoPriceXaf) {
      return this.promoPriceXaf;
    }
    return this.priceXaf;
  }

  public getDiscountAmount(): number {
    if (this.hasPromotion() && this.promoPriceXaf) {
      return this.priceXaf - this.promoPriceXaf;
    }
    return 0;
  }

  public getPrimaryImage(): ProductImage | null {
    return this.images.find(img => img.position === 0) || this.images[0] || null;
  }

  public getHighlightedFeatures(): ProductFeature[] {
    return this.features.filter(feature => feature.highlight);
  }

  public canBeDeleted(): boolean {
    // Check if product is referenced in orders, cart items, etc.
    return this.stockQty === 0 && !this.hasVariants;
  }

  /**
   * Génère un slug à partir du nom du produit
   * Note: La génération se fait côté application car il n'y a pas de trigger SQL pour les slugs
   * Le SKU est auto-généré par les triggers SQL assign_sku_from_category et get_next_sku
   */
  public static generateSlug(name: string, existingSlugs: string[] = []): string {
    let baseSlug = name
      .toLowerCase()
      .normalize('NFD')
      .replace(/[\u0300-\u036f]/g, '') // Remove accents
      .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
      .replace(/\s+/g, '-') // Replace spaces with hyphens
      .replace(/-+/g, '-') // Replace multiple hyphens with single
      .replace(/^-|-$/g, ''); // Remove leading/trailing hyphens

    // Handle uniqueness
    let slug = baseSlug;
    let counter = 1;
    while (existingSlugs.includes(slug)) {
      slug = `${baseSlug}-${counter}`;
      counter++;
    }

    return slug;
  }
}

export interface CreateProductDto {
  name: string;
  slug?: string; // Optional, will be auto-generated if not provided
  categoryId: string;
  brandId?: string;
  seriesId?: string;
  priceXaf: number;
  promoPct?: number;
  promoPriceXaf?: number;
  stockQty?: number;
  weightKg?: number;
  dimensionsMm?: Record<string, number>;
  description?: string;
  tier?: ProductTierEnum;
  specifications?: Omit<ProductSpecification, 'id'>[];
  features?: Omit<ProductFeature, 'id'>[];
  images?: Omit<ProductImage, 'id'>[];
}

export interface UpdateProductDto {
  name?: string;
  slug?: string;
  categoryId?: string;
  brandId?: string;
  seriesId?: string;
  priceXaf?: number;
  promoPct?: number;
  promoPriceXaf?: number;
  stockQty?: number;
  weightKg?: number;
  dimensionsMm?: Record<string, number>;
  description?: string;
  tier?: ProductTierEnum;
}

export interface ProductFilters {
  categoryId?: string;
  brandId?: string;
  seriesId?: string;
  tier?: ProductTierEnum;
  minPrice?: number;
  maxPrice?: number;
  inStock?: boolean;
  hasPromotion?: boolean;
  search?: string;
}

export interface ProductListOptions {
  filters?: ProductFilters;
  includeCategory?: boolean;
  includeBrand?: boolean;
  includeSeries?: boolean;
  includeImages?: boolean;
  includeSpecs?: boolean;
  includeFeatures?: boolean;
  includeVariants?: boolean;
  sortBy?: "name" | "priceXaf" | "createdAt" | "stockQty";
  sortOrder?: "asc" | "desc";
  page?: number;
  limit?: number;
}

export interface ProductListResult {
  products: Product[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}
